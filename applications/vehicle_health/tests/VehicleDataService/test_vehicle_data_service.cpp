// test_vehicle_data_service.cpp
// Auto-generated by VisCar SDV GenAI Framework (Jules)
// GoogleTest Suite with ASPICE Traceability

#include <gtest/gtest.h>
#include "../../services/VehicleDataService/VehicleDataService.cpp"
#include <thread>
#include <chrono>

using namespace sdv::services;

// Test Fixture
class VehicleDataServiceTest : public ::testing::Test {
protected:
    VehicleDataService* service;
    
    void SetUp() override {
        service = new VehicleDataService();
    }
    
    void TearDown() override {
        if (service) {
            service->shutdown();
            delete service;
        }
    }
};

// Traces to: FR-001, SWR-001
TEST_F(VehicleDataServiceTest, InitializationSuccess) {
    // Arrange & Act
    bool result = service->initialize();
    
    // Assert
    EXPECT_TRUE(result);
    EXPECT_EQ(service->getLastError(), "");
}

// Traces to: FR-001, SWR-001
TEST_F(VehicleDataServiceTest, DoubleInitializationFails) {
    // Arrange
    service->initialize();
    
    // Act
    bool result = service->initialize();
    
    // Assert
    EXPECT_FALSE(result);
    EXPECT_NE(service->getLastError(), "");
}

// Traces to: FR-001, SWR-001
TEST_F(VehicleDataServiceTest, GetDataWithoutInitializationFails) {
    // Act
    bool result = service->getData();
    
    // Assert
    EXPECT_FALSE(result);
}

// Traces to: FR-001, SWR-001
TEST_F(VehicleDataServiceTest, GetDataReturnsValidTelemetry) {
    // Arrange
    service->initialize();
    
    // Act
    bool result = service->getData();
    VehicleState state = service->getCurrentState();
    
    // Assert
    EXPECT_TRUE(result);
    EXPECT_GE(state.speed, 0.0);
    EXPECT_LE(state.speed, 120.0);
    EXPECT_GE(state.battery_soc, 0.0);
    EXPECT_LE(state.battery_soc, 100.0);
}

// Traces to: FR-001, SWR-001
TEST_F(VehicleDataServiceTest, TyrePressureInValidRange) {
    // Arrange
    service->initialize();
    service->getData();
    
    // Act
    VehicleState state = service->getCurrentState();
    
    // Assert
    EXPECT_GE(state.tyre_pressure_fl, 25.0);
    EXPECT_LE(state.tyre_pressure_fl, 40.0);
    EXPECT_GE(state.tyre_pressure_fr, 25.0);
    EXPECT_LE(state.tyre_pressure_fr, 40.0);
    EXPECT_GE(state.tyre_pressure_rl, 25.0);
    EXPECT_LE(state.tyre_pressure_rl, 40.0);
    EXPECT_GE(state.tyre_pressure_rr, 25.0);
    EXPECT_LE(state.tyre_pressure_rr, 40.0);
}

// Traces to: FR-001, SWR-001
TEST_F(VehicleDataServiceTest, GearCalculationBasedOnSpeed) {
    // Arrange
    service->initialize();
    
    // Act - multiple updates to get different speeds
    for (int i = 0; i < 5; ++i) {
        service->getData();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    VehicleState state = service->getCurrentState();
    
    // Assert - gear should be appropriate for speed
    if (state.speed < 20.0) {
        EXPECT_EQ(state.gear, 1);
    } else if (state.speed >= 80.0) {
        EXPECT_GE(state.gear, 4);
    }
}

// Traces to: FR-001, SWR-001
TEST_F(VehicleDataServiceTest, SensorDataGeneration) {
    // Arrange
    service->initialize();
    
    // Act
    service->getData();
    std::vector<SensorData> sensors = service->getSensorData();
    
    // Assert
    EXPECT_GE(sensors.size(), 6);  // At least speed, battery, 4 tyres
    
    // Verify sensor data structure
    for (const auto& sensor : sensors) {
        EXPECT_NE(sensor.id, "");
        EXPECT_NE(sensor.sensor_type, "");
        EXPECT_NE(sensor.unit, "");
        EXPECT_GT(sensor.timestamp, 0.0);
    }
}

// Traces to: FR-003, NFR-001
TEST_F(VehicleDataServiceTest, SubscribeSuccess) {
    // Arrange
    service->initialize();
    
    // Act
    bool result = service->subscribe();
    
    // Assert
    EXPECT_TRUE(result);
}

// Traces to: NFR-002
TEST_F(VehicleDataServiceTest, ConfigureSuccess) {
    // Arrange
    service->initialize();
    
    // Act
    bool result = service->configure();
    
    // Assert
    EXPECT_TRUE(result);
}

// Traces to: FR-001
TEST_F(VehicleDataServiceTest, ShutdownSuccess) {
    // Arrange
    service->initialize();
    
    // Act
    bool result = service->shutdown();
    
    // Assert
    EXPECT_TRUE(result);
}

// Traces to: NFR-001 (Performance)
TEST_F(VehicleDataServiceTest, PerformanceUnder100ms) {
    // Arrange
    service->initialize();
    
    // Act
    auto start = std::chrono::high_resolution_clock::now();
    service->getData();
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // Assert
    EXPECT_LT(duration.count(), 100);  // Should complete in under 100ms
}

// Traces to: SR-001 (Safety)
TEST_F(VehicleDataServiceTest, EVRangeNeverNegative) {
    // Arrange
    service->initialize();
    
    // Act - run multiple updates
    for (int i = 0; i < 20; ++i) {
        service->getData();
        VehicleState state = service->getCurrentState();
        
        // Assert
        EXPECT_GE(state.ev_range, 0.0);
    }
}

// Boundary Value Test
TEST_F(VehicleDataServiceTest, BatteryBoundaryValues) {
    // Arrange
    service->initialize();
    
    // Act - simulate extended operation
    for (int i = 0; i < 100; ++i) {
        service->getData();
    }
    
    VehicleState state = service->getCurrentState();
    
    // Assert - battery should never exceed bounds
    EXPECT_GE(state.battery_soc, 0.0);
    EXPECT_LE(state.battery_soc, 100.0);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
