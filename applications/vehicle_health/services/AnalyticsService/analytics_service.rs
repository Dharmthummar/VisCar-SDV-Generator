// analytics_service.rs
// Auto-generated by VisCar SDV GenAI Framework
// Full working implementation with trend analysis

use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH};
use std::error::Error;

/// Data Model: TrendData
#[derive(Debug, Clone)]
pub struct TrendData {
    pub metric_name: String,
    pub timestamps: Vec<f64>,
    pub values: Vec<f64>,
    pub trend_direction: String,
    pub average: f64,
    pub min_value: f64,
    pub max_value: f64,
}

impl TrendData {
    pub fn new(metric_name: &str) -> Self {
        Self {
            metric_name: metric_name.to_string(),
            timestamps: Vec::new(),
            values: Vec::new(),
            trend_direction: "STABLE".to_string(),
            average: 0.0,
            min_value: 0.0,
            max_value: 0.0,
        }
    }
    
    pub fn add_data_point(&mut self, timestamp: f64, value: f64) {
        self.timestamps.push(timestamp);
        self.values.push(value);
        self.update_statistics();
    }
    
    fn update_statistics(&mut self) {
        if self.values.is_empty() {
            return;
        }
        
        // Calculate average
        self.average = self.values.iter().sum::<f64>() / self.values.len() as f64;
        
        // Find min/max
        self.min_value = self.values.iter().cloned().fold(f64::INFINITY, f64::min);
        self.max_value = self.values.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
        
        // Determine trend direction
        if self.values.len() >= 2 {
            let recent_avg = self.values[self.values.len().saturating_sub(5)..]
                .iter()
                .sum::<f64>() / 5.0_f64.min(self.values.len() as f64);
            let older_avg = self.values[..self.values.len().saturating_sub(5)]
                .iter()
                .sum::<f64>() / (self.values.len().saturating_sub(5) as f64).max(1.0);
            
            let diff_pct = ((recent_avg - older_avg) / older_avg.max(0.001)) * 100.0;
            
            self.trend_direction = if diff_pct > 5.0 {
                "INCREASING".to_string()
            } else if diff_pct < -5.0 {
                "DECREASING".to_string()
            } else {
                "STABLE".to_string()
            };
        }
    }
}

impl Default for TrendData {
    fn default() -> Self {
        Self::new("unknown")
    }
}

/// Data Model: AnalyticsReport
#[derive(Debug, Clone)]
pub struct AnalyticsReport {
    pub id: String,
    pub generated_at: f64,
    pub summary: String,
    pub trends: Vec<TrendData>,
    pub anomalies_detected: Vec<String>,
    pub insights: Vec<String>,
}

impl AnalyticsReport {
    pub fn new() -> Self {
        Self {
            id: format!("REPORT-{}", Self::get_timestamp()),
            generated_at: Self::get_timestamp(),
            summary: String::new(),
            trends: Vec::new(),
            anomalies_detected: Vec::new(),
            insights: Vec::new(),
        }
    }
    
    fn get_timestamp() -> f64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs_f64()
    }
}

impl Default for AnalyticsReport {
    fn default() -> Self {
        Self::new()
    }
}

/// Service: AnalyticsService
#[derive(Clone)]
pub struct AnalyticsService {
    state: Arc<Mutex<ServiceState>>,
}

#[derive(Debug)]
struct ServiceState {
    initialized: bool,
    last_error: Option<String>,
    start_time: Option<SystemTime>,
    historical_data: Vec<TrendData>,
}

impl AnalyticsService {
    pub fn new() -> Self {
        Self {
            state: Arc::new(Mutex::new(ServiceState {
                initialized: false,
                last_error: None,
                start_time: None,
                historical_data: Vec::new(),
            })),
        }
    }
    
    pub fn initialize(&self) -> Result<(), Box<dyn Error>> {
        let mut state = self.state.lock().unwrap();
        
        if state.initialized {
            return Err("Service already initialized".into());
        }
        
        state.initialized = true;
        state.start_time = Some(SystemTime::now());
        state.last_error = None;
        
        // Initialize default metrics
        state.historical_data.push(TrendData::new("speed"));
        state.historical_data.push(TrendData::new("battery_soc"));
        state.historical_data.push(TrendData::new("tyre_pressure"));
        
        println!("[AnalyticsService] Service initialized successfully");
        Ok(())
    }
    
    pub fn shutdown(&self) -> Result<(), Box<dyn Error>> {
        let mut state = self.state.lock().unwrap();
        
        if !state.initialized {
            return Err("Service not initialized".into());
        }
        
        state.initialized = false;
        state.start_time = None;
        
        println!("[AnalyticsService] Service shut down");
        Ok(())
    }
    
    pub fn add_metric_data(&self, metric_name: &str, value: f64) -> Result<(), Box<dyn Error>> {
        let mut state = self.state.lock().unwrap();
        
        if !state.initialized {
            return Err("Service not initialized".into());
        }
        
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs_f64();
        
        // Find or create trend
        let trend = state.historical_data
            .iter_mut()
            .find(|t| t.metric_name == metric_name);
        
        if let Some(trend) = trend {
            trend.add_data_point(timestamp, value);
        } else {
            let mut new_trend = TrendData::new(metric_name);
            new_trend.add_data_point(timestamp, value);
            state.historical_data.push(new_trend);
        }
        
        Ok(())
    }
    
    pub fn analyze_trends(&self) -> Result<Vec<TrendData>, Box<dyn Error>> {
        let state = self.state.lock().unwrap();
        
        if !state.initialized {
            return Err("Service not initialized".into());
        }
        
        Ok(state.historical_data.clone())
    }
    
    pub fn generate_report(&self) -> Result<AnalyticsReport, Box<dyn Error>> {
        let state = self.state.lock().unwrap();
        
        if !state.initialized {
            return Err("Service not initialized".into());
        }
        
        let mut report = AnalyticsReport::new();
        report.trends = state.historical_data.clone();
        
        // Generate insights
        for trend in &state.historical_data {
            if trend.values.len() > 5 {
                let insight = format!(
                    "{}: {} (avg: {:.2}, range: {:.2}-{:.2})",
                    trend.metric_name,
                    trend.trend_direction,
                    trend.average,
                    trend.min_value,
                    trend.max_value
                );
                report.insights.push(insight);
            }
        }
        
        // Detect anomalies
        for trend in &state.historical_data {
            if trend.metric_name == "battery_soc" && trend.average < 30.0 {
                report.anomalies_detected.push("Low battery average detected".to_string());
            }
            if trend.metric_name == "tyre_pressure" &&  (trend.min_value < 28.0) {
                report.anomalies_detected.push("Low tyre pressure detected".to_string());
            }
        }
        
        report.summary = format!(
            "Analytics report generated with {} metrics tracked and {} anomalies detected",
            report.trends.len(),
            report.anomalies_detected.len()
        );
        
        Ok(report)
    }
    
    pub fn get_last_error(&self) -> Option<String> {
        let state = self.state.lock().unwrap();
        state.last_error.clone()
    }
    
    pub fn is_initialized(&self) -> bool {
        let state = self.state.lock().unwrap();
        state.initialized
    }
}

impl Default for AnalyticsService {
    fn default() -> Self {
        Self::new()
    }
}

unsafe impl Send for AnalyticsService {}
unsafe impl Sync for AnalyticsService {}

// Standalone demo
fn main() {
    println!("AnalyticsService Demo\n");
    
    let service = AnalyticsService::new();
    
    if let Err(e) = service.initialize() {
        eprintln!("Failed to initialize: {}", e);
        return;
    }
    
    // Simulate data collection
    println!("Collecting vehicle data...\n");
    for i in 0..20 {
        let _ = service.add_metric_data("speed", 60.0 + (i as f64 * 2.0));
        let _ = service.add_metric_data("battery_soc", 85.0 - (i as f64 * 1.5));
        let _ = service.add_metric_data("tyre_pressure", 32.0 + ((i as f64 / 5.0).sin()));
    }
    
    // Analyze trends
    match service.analyze_trends() {
        Ok(trends) => {
            println!("Trend Analysis:");
            for trend in trends {
                println!("  {}: {} (avg: {:.2}, min/max: {:.2}/{:.2})",
                    trend.metric_name,
                    trend.trend_direction,
                    trend.average,
                    trend.min_value,
                    trend.max_value
                );
            }
        }
        Err(e) => eprintln!("Error analyzing trends: {}", e),
    }
    
    // Generate report
    println!("\nGenerating report...");
    match service.generate_report() {
        Ok(report) => {
            println!("\nReport ID: {}", report.id);
            println!("Generated at: {}", report.generated_at);
            println!("Summary: {}", report.summary);
            
            if !report.insights.is_empty() {
                println!("\nInsights:");
                for insight in &report.insights {
                    println!("  • {}", insight);
                }
            }
            
            if !report.anomalies_detected.is_empty() {
                println!("\nAnomalies:");
                for anomaly in &report.anomalies_detected {
                    println!("  ⚠ {}", anomaly);
                }
            }
        }
        Err(e) => eprintln!("Error generating report: {}", e),
    }
    
    let _ = service.shutdown();
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_initialization() {
        let service = AnalyticsService::new();
        assert!(service.initialize().is_ok());
        assert!(service.is_initialized());
    }
    
    #[test]
    fn test_add_metric_data() {
        let service = AnalyticsService::new();
        service.initialize().unwrap();
        
        assert!(service.add_metric_data("speed", 75.0).is_ok());
        assert!(service.add_metric_data("battery", 85.0).is_ok());
    }
    
    #[test]
    fn test_trend_analysis() {
        let service = AnalyticsService::new();
        service.initialize().unwrap();
        
        for i in 0..10 {
            service.add_metric_data("speed", 60.0 + i as f64).unwrap();
        }
        
        let trends = service.analyze_trends().unwrap();
        assert!(!trends.is_empty());
        
        let speed_trend = trends.iter().find(|t| t.metric_name == "speed").unwrap();
        assert!(speed_trend.average > 60.0);
        assert_eq!(speed_trend.trend_direction, "INCREASING");
    }
    
    #[test]
    fn test_report_generation() {
        let service = AnalyticsService::new();
        service.initialize().unwrap();
        
        service.add_metric_data("speed", 75.0).unwrap();
        service.add_metric_data("battery_soc", 80.0).unwrap();
        
        let report = service.generate_report().unwrap();
        assert!(!report.summary.is_empty());
        assert!(!report.trends.is_empty());
    }
}
